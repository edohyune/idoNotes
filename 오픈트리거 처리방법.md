---
Start Date: 
Status: 
Concept: false
Manifestation: false
Integration: false
Done: 
tags: 
CDT: <% tp.file.creation_date() %>
MDT: <% tp.file.last_modified_date() %>
---

## Prologue / Concept
### 첫 번째 관점---

주로 그리드셋에서는 FocusedRow가 변경되면, 필드셋에서는 특정 컨트롤러들의 값이 변경되면 자신 이후의 워크셋을 오픈 순서에 따라 다시 오픈합니다. 이 방법은 데이터를 변경할 때 해당 데이터를 사용하는 이후 워크셋이 영향을 받을 수 있는 경우 유용합니다.

#### 장점

1. **명확한 흐름 제어**: 특정 이벤트가 발생했을 때 이후의 워크셋만 다시 오픈하므로 데이터 흐름이 명확합니다.
2. **부분 업데이트**: 필요한 부분만 업데이트하므로 성능 측면에서 효율적입니다.

#### 단점

1. **복잡한 이벤트 관리**: 여러 워크셋에서 이벤트를 관리하고, 각 워크셋마다 특정 이벤트를 정의하고 처리해야 합니다.
2. **다양한 이벤트 처리**: 각 워크셋의 이벤트 처리 로직이 다를 수 있어 유지보수가 어려울 수 있습니다.

### 두 번째 관점

워크셋 입장에서 자신의 워크셋이 오픈될 때, 워크셋은 WrkSet Get하게 되는데, 이 WrkSet Get의 데이터가 변경이 되면 자신의 워크셋을 다시 오픈합니다. 이 방법은 데이터 변경 시 해당 데이터와 직접적으로 연관된 워크셋만 다시 오픈하므로, 데이터 종속성이 높은 경우에 유용합니다.

#### 장점

1. **간단한 이벤트 관리**: 각 워크셋이 자신의 데이터 변경을 감지하고 처리하므로 이벤트 관리가 간단합니다.
2. **명확한 종속성 관리**: 워크셋 간의 종속성을 명확히 관리할 수 있습니다.

#### 단점

1. **전체적인 성능 저하 가능성**: 변경이 발생할 때마다 해당 워크셋을 다시 오픈하므로, 빈번한 변경이 발생할 경우 성능 저하가 발생할 수 있습니다.
2. **복잡한 데이터 추적**: WrkSet Get의 데이터 변경을 추적하고 처리하는 로직이 복잡할 수 있습니다.

### 선택 기준

- **워크셋 간의 종속성이 명확하고 빈번한 변경이 발생하는 경우**: 첫 번째 관점이 더 적합합니다. 필요한 부분만 부분적으로 업데이트하므로 성능 측면에서 유리할 수 있습니다.
- **단순한 이벤트 관리와 명확한 종속성 관리가 필요한 경우**: 두 번째 관점이 더 적합합니다. 각 워크셋이 자신의 데이터를 관리하고 변경을 감지하므로 유지보수 측면에서 유리할 수 있습니다.


---

### 질문 1: 데이터 변경 빈도와 영향 범위

- 데이터 변경이 자주 발생합니까?
- 데이터 변경이 다른 워크셋에 미치는 영향이 큽니까?

### 질문 2: 성능 요구사항

- 데이터 변경 이벤트가 발생할 때마다 전체 워크셋을 다시 오픈하는 것이 성능에 큰 영향을 미칠까요?
- 부분 업데이트가 가능한 구조로 데이터 처리를 해야 합니까?

### 질문 3: 이벤트 관리의 복잡성

- 각 워크셋에서 발생하는 다양한 이벤트를 관리할 준비가 되어 있습니까?
- 단일 이벤트 처리 방식이 더 단순하고 유지보수가 쉬운가요?

### 질문 4: 워크셋 간의 종속성

- 워크셋 간의 종속성이 명확하고 강한가요?
- 특정 워크셋의 변경이 이후의 모든 워크셋에 영향을 미칩니까?

### 질문 5: 유지보수 및 확장성

- 이벤트를 개별적으로 관리하는 것이 유지보수에 더 유리할까요?
- 데이터 변경을 단순하게 감지하고 처리하는 방식이 더 확장성이 있나요?

### 결과 결정

- **첫 번째 관점 (이벤트 기반 오픈 순서 재오픈)**:
    - 데이터 변경이 자주 발생하고, 부분 업데이트가 성능에 중요하다면.
    - 이벤트 관리의 복잡성을 감수할 수 있다면.
    - 워크셋 간의 종속성이 명확하고 강하다면.
    
- **두 번째 관점 (워크셋 데이터 변경 감지)**:
    - 데이터 변경이 드물고, 전체 워크셋을 다시 오픈해도 성능에 큰 영향을 미치지 않는다면.
    - 단일 이벤트 처리 방식이 유지보수에 더 유리하다면.
    - 워크셋 간의 종속성이 약하거나, 특정 워크셋의 변경이 다른 워크셋에 큰 영향을 미치지 않는다면.

이 질문들을 통해 어느 관점이 더 적합한지 결정할 수 있습니다. 질문에 대한 답변을 바탕으로 결정을 내리세요.


프로그램은 데이터베이스의 마스터 디테일 참조키를 공유하여 연결한다. 
대부분이 마스터 디테일 형태의 테이블 구조이다. 
WrkSet Get하는 데이터는 거의 참조키이다. 
Save는 바인딩 데이터의 변경감지를 통해 변경된 것 MdlStat.Insert, Update 상황만 처리하도록 설계하기 때문에 상위 문서는 Save상황에 영향없이 하위문서만 저장되는 경우가 많다. 
종속성은 명확하다. 

## Manifestation

## Integration

자신에 변경이 있으면 자신을 WrkGet하여 열리는 워크셋을 오픈하는 것으로 구현
최초의 오픈 역시 FrmWrk.StartYn=true 인것에 한하여 오픈하고 나머지는 자동으로 오픈되도록 한다. 

FrmBase.cs
```C#
private void WorkSet_DataChanged(object sender, DataChangedEventArgs e)
{
	var changedWorkSet = sender as IWorkSet;

	if (changedWorkSet == null)
		return;

	// 자신의 그리드를 Get하는 워크셋 목록을 가져옵니다.
	WrkGetRepo wrkGetRepo = new WrkGetRepo();
	var pullWrks = wrkGetRepo.GetPullWrks(changedWorkSet.frwId, changedWorkSet.frmId, changedWorkSet.wrkId);

	foreach (var wrkSet in pullWrks)
	{
		if (wrkSet.WrkId == changedWorkSet.wrkId)
		{
			var fieldSet = fieldSets.Find(fs => fs.wrkId == wrkSet.WrkId);
			fieldSet?.Open();

			var gridSet = gridSets.Find(gs => gs.wrkId == wrkSet.WrkId);
			gridSet?.Open();
		}
	}
}
```

UCFieldSet.cs
```C#
private void OnControlValueChanged(string fieldName, dynamic newValue)
{
	// 동적 모델에 새로운 값을 설정
	Model.SetDynamicProperty(fieldName, newValue);
	// 데이터 변경 이벤트를 트리거
	OnDataChanged(new DataChangedEventArgs(fieldName, newValue));
}

public event EventHandler<DataChangedEventArgs> DataChanged;

public virtual void OnDataChanged(DataChangedEventArgs e)
{
	DataChanged?.Invoke(this, e);
}
```

UCGridNav.cs
```C#
public delegate void delEventFocusedRowChanged(object sender, int preIndex, int rowIndex, FocusedRowChangedEventArgs e);
public event delEventFocusedRowChanged UCFocusedRowChanged;
public void gvCtrl_FocusedRowChanged(object sender, FocusedRowChangedEventArgs e)
{
	if (e.PrevFocusedRowHandle >= 0 && gvCtrl.IsNewItemRow(e.PrevFocusedRowHandle))
	{
		gvCtrl.UpdateCurrentRow(); // 포커스 이동 시 행 추가 확정
	}

	if (UCFocusedRowChanged != null && e.FocusedRowHandle >= 0)
	{
		List<WrkSet> ctrls = new WrkSetRepo().SetPushFlds(frwId, frmId, wrkId);
		if (ctrls != null)
		{
			var fieldInfo = ctrls.ToDictionary(x => x.FldNm, x => x.ToolNm);
			var mapping = ctrls.ToDictionary(x => x.FldNm, x => x.SetFldNm);

			foreach (var item in fieldInfo)
			{
				// item.Key에 해당하는 매핑된 컬럼 이름을 가져옴
				string columnName = mapping.ContainsKey(item.Key) ? item.Key : null;
				if (columnName != null)
				{
					// GetText 메서드를 사용하여 값을 가져옴
					var fieldValue = this.GetText(columnName);
					if (fieldValue != null)
					{
						Common.gMsg = $"Enter Value({fieldValue}) into Control({mapping[item.Key]})";
						SetControlValue(this.FindForm(), mapping[item.Key], item.Value, fieldValue);
					}
					else
					{
						Common.gMsg = $"Value for column {columnName} is null.";
					}
				}
				else
				{
					Common.gMsg = $"Column name for key {item.Key} is null.";
				}
			}
		}
		UCFocusedRowChanged(sender, e.PrevFocusedRowHandle, e.FocusedRowHandle, e);
	}
	// 포커스가 변경된 후 새로운 행의 값을 기반으로 DataChanged 이벤트를 트리거
	var focusedRow = gvCtrl.GetRow(e.FocusedRowHandle);
	if (focusedRow != null)
	{
		var newValue = focusedRow; // 전체 행 객체를 값으로 설정할 수 있습니다.
		OnDataChanged(new Lib.DataChangedEventArgs("FocusedRowChanged", newValue));
	}
}

public event EventHandler<Lib.DataChangedEventArgs> DataChanged;
public void OnDataChanged(Lib.DataChangedEventArgs e)
{
	DataChanged?.Invoke(this, e);
}
```

###### REFERENCE



```C#

```

```C#

```

